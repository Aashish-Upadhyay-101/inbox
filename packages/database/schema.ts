import {
  integer,
  pgEnum,
  pgTable,
  varchar,
  text,
  timestamp,
  uuid,
  customType,
  boolean,
  primaryKey
} from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

import { customAlphabet } from 'nanoid/async';

const genNanoId = customAlphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 22);

async function createId() {
  return await genNanoId();
}

const nanoId = customType<{ data: string | undefined; notNull: true }>({
  dataType() {
    return 'varchar(22)'; // match the length of the nanoid
  },
  toDriver(value?: string) {
    return value ?? createId(); // if no value, generate a new id - need to pass *undefined* to the driver - check https://github.com/drizzle-team/drizzle-orm/issues/304 for fix
  }
});

export const users = pgTable('users', {
  id: nanoId('id').primaryKey(),
  hankoId: uuid('id').notNull(), // Passed in from Hanko Auth, Not generated by Drizzle/locally
  username: varchar('username', { length: 32 }).notNull(), // ToDo: Add unique when implemented in Drizzle
  backupEmail: varchar('backup_email', { length: 128 }).notNull(), // ToDo: Add unique when implemented in Drizzle
  name: varchar('name', { length: 128 }).notNull(),
  invitedBy: uuid('invited_by'),
  createdAt: timestamp('created_at').notNull().defaultNow()
});

export const userRelations = relations(users, ({ one, many }) => ({
  invitee: one(users, {
    fields: [users.invitedBy],
    references: [users.id]
  }),
  usersToOrgs: many(usersToOrgs)
}));

// FIXME: add Members in Orgs table with roles enum + invited by

export const orgs = pgTable('org', {
  id: nanoId('id').primaryKey(),
  name: varchar('name', { length: 128 }).notNull(),
  slug: varchar('slug', { length: 128 }).notNull(), // ToDo: Add unique when implemented in Drizzle
  createdAt: timestamp('created_at').notNull().defaultNow()
});

export const orgsRelations = relations(orgs, ({ many }) => ({
  usersToOrgs: many(usersToOrgs)
}));

export const userOrgRole = pgEnum('user_org_role', ['owner', 'admin', 'member', 'invited']);

export const usersToOrgs = pgTable(
  'users_to_orgs',
  {
    userId: nanoId('user_id')
      .notNull()
      .references(() => users.id),
    orgId: nanoId('org_id')
      .notNull()
      .references(() => orgs.id),
    role: userOrgRole('role').notNull().default('member')
  },
  (t) => ({
    pk: primaryKey(t.userId, t.orgId)
  })
);

export const usersToOrgsRelations = relations(usersToOrgs, ({ one }) => ({
  org: one(orgs, {
    fields: [usersToOrgs.orgId],
    references: [orgs.id]
  }),
  user: one(users, {
    fields: [usersToOrgs.userId],
    references: [users.id]
  })
}));

export const domains = pgTable('domains', {
  id: nanoId('id').primaryKey(),
  name: varchar('name', { length: 128 }).notNull(),
  dkim: varchar('dkim'), // can be null because we generate it after the fact
  dnsPass: boolean('dns_pass').notNull().default(false),
  lastDnsCheck: timestamp('last_dns_check'),
  failCode: varchar('fail_code'),
  failCount: integer('fail_count').notNull().default(0),
  createdAt: timestamp('created_at').notNull().defaultNow()
});

// FIXME: Relationship: add domains to org

export const addresses = pgTable('addresses', {
  id: nanoId('id').primaryKey(),
  username: varchar('username', { length: 64 }).notNull(),
  domain: varchar('domain', { length: 128 }).notNull(),
  nickname: varchar('nickname', { length: 128 }),
  sendname: varchar('sendname', { length: 128 }),
  groupBySender: boolean('group_by_sender').notNull().default(false),
  createdAt: timestamp('created_at').notNull().defaultNow()
});

// FIXME: Relationship: add addresses to org, domain, users(as mnembers)

export const externalSenders = pgTable('external_senders', {
  id: nanoId('id').primaryKey(),
  domain: varchar('domain', { length: 128 }).notNull(),
  username: varchar('username', { length: 64 }).notNull(),
  sendname: varchar('sendname', { length: 128 }),
  signature: varchar('signature'),
  signatureHtml: varchar('signature_html'),
  createdAt: timestamp('created_at').notNull().defaultNow()
});

// FIXME: Relationship: add externalSenders to address

export const convos = pgTable('convos', {
  id: nanoId('id').primaryKey(),
  lastMessageAt: timestamp('last_message_at'),
  subject: varchar('subject', { length: 1024 }),
  createdAt: timestamp('created_at').notNull().defaultNow()
});

// FIXME: Relationship: add convos to internal members and addresses, external senders, convo events and SMTPRefIDs

export const convoEventAuthor = pgEnum('convo_event_author', ['internal', 'external']);

export const convoEventStatus = pgEnum('convo_event_status', ['queued', 'processing', 'complete']);

export const convoEventTyoe = pgEnum('convo_event_type', ['internal', 'external', 'comment']);

export const convoEvents = pgTable('convo_events', {
  id: nanoId('id').primaryKey(),
  authorType: convoEventAuthor('author_type').notNull(),
  status: convoEventStatus('status').notNull(),
  message: varchar('message'),
  tldr: varchar('tldr'),
  createdAt: timestamp('created_at').notNull().defaultNow()
});

// FIXME: Relationship: add convoEvents to convos, author internal+external, raw mail ID

export const rawMails = pgTable('raw_mails', {
  id: nanoId('id').primaryKey(),
  fromAddress: varchar('from_address', { length: 128 }).notNull(),
  fromName: varchar('from_name', { length: 128 }),
  toAddress: varchar('to_address', { length: 128 }).notNull(),
  toName: varchar('to_name', { length: 128 }),
  subject: varchar('subject', { length: 1024 }),
  rawBody: text('raw_body'),
  messageId: varchar('message_id', { length: 1024 }),
  inReplyTo: varchar('in_reply_to', { length: 1024 }),
  html: text('html'),
  text: text('text'),
  createdAt: timestamp('created_at').notNull().defaultNow()
});
